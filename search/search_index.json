{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Cpwiki","text":"<p>I'm Abu Rifat Muhammed! This is my personal programming blog. The main perpose of creating this blog is to sharing ideas and codes with others and keep them open to all. The articles are be based on,</p> <ul> <li>Algorithms &amp; Data Structures</li> <li>Solution to online judge problems</li> <li>Contest Discussions</li> <li>Other Programming Related Discussions</li> </ul>"},{"location":"#topics","title":"Topics","text":"<ul> <li>Dynamic Programming</li> <li>Graph Theory</li> <li>Data Structures</li> <li>Number Theory</li> <li>Programming Tips and Tricks</li> </ul>"},{"location":"#online-judges","title":"Online Judges","text":"<ul> <li>Leetcode</li> <li>LightOJ</li> <li>UVA (Online Judge)</li> <li>Codeforces</li> </ul>"},{"location":"#programming-language","title":"Programming Language","text":"<ul> <li>C++</li> <li>C#</li> </ul>"},{"location":"Algorithm/sort/","title":"Sorting Algorithms","text":"<ol> <li>Bubble Sort</li> <li>Insertion Sort</li> <li>Merge Sort</li> <li>Tim Sort</li> <li>Counting Sort</li> </ol>","tags":["sorting","C","C++","Python","C#"]},{"location":"Algorithm/sort/#bubble-sort","title":"Bubble Sort","text":"<ul> <li>Time Complexity: O(n2)</li> <li>Auxiliary Space: O(1)</li> </ul> <pre><code>void bubble_sort( int *arr, int l, int r ) {\nfor ( int i = l; i &lt;= r; i++ ) {\nfor ( int j = i + 1; j &lt;= r; j++ ) {\nif ( arr[i] &gt; arr[j] ) {\nint tmp = arr[i];\narr[i] = arr[j];\narr[j] = tmp;\n}\n}\n}\n}\n</code></pre>","tags":["sorting","C","C++","Python","C#"]},{"location":"Algorithm/sort/#insertion-sort","title":"Insertion Sort","text":"<ul> <li>Time Complexity: O(n2)</li> <li>Auxiliary Space: O(1)</li> </ul> <pre><code>void insertion_sort( int *arr, int l, int r ) {\nfor ( int i = l; i &lt;= r ; i++ ) {\nint key = arr[i];\nint j = i-1;\nwhile( j &gt;= l &amp;&amp; arr[j] &gt; key ) {\narr[j + 1] = arr[j];\nj--;\n}\narr[j + 1] = key;\n}\n}\n</code></pre>","tags":["sorting","C","C++","Python","C#"]},{"location":"Algorithm/sort/#merge-sort","title":"Merge Sort","text":"<ul> <li>Time Complexity: O(nlogn)</li> <li>Auxiliary Space: O(n)</li> </ul> <pre><code>void merge ( int *arr, int l, int mid, int r ) {\nint len_left = mid - l + 1;\nint len_right = r - mid;\nauto left = new int[len_left];\nauto right = new int[len_right];\nfor ( int i = 0; i &lt; len_left; i++ ) left[i] = arr[l + i];\nfor ( int i = 0; i &lt;len_right; i++ ) right[i] = arr[mid + i + 1];\nint idx_left = 0, idx_right = 0, idx_arr = l;\nwhile ( idx_left &lt; len_left &amp;&amp; idx_right &lt; len_right ) {\nif ( left[idx_left] &lt;= right[idx_right] ) {\narr[idx_arr] = left[idx_left];\nidx_left++;\n}\nelse{\narr[idx_arr] = right[idx_right];\nidx_right++;\n}\nidx_arr++;\n}\nwhile ( idx_left &lt; len_left ) {\narr[idx_arr] = left[idx_left];\nidx_left++;\nidx_arr++;\n}\nwhile ( idx_right &lt; len_right ) {\narr[idx_arr] = right[idx_right];\nidx_right++;\nidx_arr++;\n}\ndelete[] left;\ndelete[] right;\n}\nvoid merge_sort( int *arr, int l, int r ) {\nif ( l &lt; r ){\nint mid = l + (r - l) / 2;\nmerge_sort(arr, l, mid);\nmerge_sort(arr, mid+1, r);\nmerge(arr, l, mid, r);\n}\n}\n</code></pre>","tags":["sorting","C","C++","Python","C#"]},{"location":"Algorithm/sort/#tim-sort","title":"Tim Sort","text":"<ul> <li>Time Complexity: O(nlogn)</li> <li>Auxiliary Space: O(n)</li> </ul> <pre><code>int min ( int a, int b ) {\nreturn a &lt; b ? a : b;\n}\nvoid tim_sort ( int *arr, int l, int r ) {\nint run = 32;\nint len = r - l + 1;\nfor ( int i = l; i &lt;= r; i += run ){\ninsertion_sort( arr, i, min ( i + run - 1, r ) );\n}\nfor ( int siz = run; siz &lt; len; siz = 2 * siz ){\nfor ( int left = l; left &lt;= r; left += 2 * siz ) {\nint mid = left + siz - 1;\nint right = min ( left + 2 * siz - 1, r );\nif ( mid &lt; right ){\nmerge ( arr, left, mid, right );\n}\n}\n}\n}\n</code></pre>","tags":["sorting","C","C++","Python","C#"]},{"location":"Algorithm/sort/#counting-sort","title":"Counting Sort","text":"<ul> <li>Time Complexity: O(n+k)</li> <li>Auxiliary Space: O(n+k)</li> </ul> <p>Where, k is the difference of maximum and minimum of all values in the array</p> <p><pre><code>void max ( int a, int b ) {\nreturn a &gt; b ? a : b;\n}\nvoid counting_sort ( int *arr, int l, int r ) {\nint min_val = arr[l];\nint max_val = arr[l];\nint len = r - l + 1;\nfor ( int i=l; i &lt;= r; i++ ) {\nmin_val = min ( min_val, arr[i] );\nmax_val = max ( max_val, arr[i] );\n}\nint dif = max_val - min_val + 1;\nint cnt[dif + 1];\nfor ( int i = 0; i &lt;= dif; i++ ) cnt[i] = 0;\nfor ( int i = l; i&lt;= r; i++ ) {\nint idx = arr[i] - min_val;\ncnt[idx]++;\n}\nfor ( int i = 1; i&lt;= dif; i++ ) {\ncnt[i] += cnt[i-1];\n}\nfor( int i = 0; i &lt;= dif; i++ ) {\nwhile( cnt[i] ){\narr[cnt[i] - 1] = i + min_val;\ncnt[i]--;\n}\n}\n}\n</code></pre> Happy Coding!</p>","tags":["sorting","C","C++","Python","C#"]},{"location":"Algorithm/Graph/cycle-finding/","title":"Cycle Finding","text":"","tags":["cycle-finding","graph","ditected","undirected"]},{"location":"Algorithm/Graph/cycle-finding/#introduction","title":"Introduction","text":"<p>Cycle can be exist in directed and undirected graph. Cycle in a graph can be detected as following,</p> <ul> <li>Using DFS.</li> <li>If back-edge exists, there is a cycle.</li> <li>Back-edge is an edge connecting the node with some of it's ansestor.</li> <li>Three values of the color array,</li> <li>0, the node is not visited yet.</li> <li>1, the node is in the DFS tree and an ancestor of the current node.</li> <li>2, visited, not an ancestor.</li> <li>Initial value of parent array is -1, which means the node have no parent.</li> <li>parent[v] = u, means u is the direct parent of v.</li> <li>Time Complexity: O(m), where m is the number of edges.</li> </ul>","tags":["cycle-finding","graph","ditected","undirected"]},{"location":"Algorithm/Graph/cycle-finding/#code","title":"Code","text":"<pre><code>#include&lt;iostream&gt;\n#include&lt;vector&gt;\nusing namespace std;\nvector&lt;vector&lt;int&gt;&gt;adj;\nvector&lt;int&gt;parent;\nvector&lt;int&gt;color;\nint cycle_start;\nint cycle_end;\nvoid init(int len){\nadj.assign(len,vector&lt;int&gt;());\nparent.assign(len,-1);\ncolor.assign(len,0);\ncycle_start = -1;\ncycle_end = -1;\n}\nbool cycleDfs(int u){\ncolor[u]=1;\nfor(int v:adj[u]){\nif(color[v]==0){\nparent[v]=u;\nif(cycleDfs(v))return true;\n}else{\n//Undirected Graph\nif(v==parent[u])continue;\n//Directed Graph\n//if(color[v]==2)continue;\n//Common\ncycle_end = u;\ncycle_start = v;\nreturn true;\n}\n}\ncolor[u]=2;\nreturn false;\n}\nvector&lt;int&gt;getCycle(){\nvector&lt;int&gt;cycle;\nif(cycle_start!=-1){\ncycle.push_back(cycle_start);\nfor(int v = cycle_end; v!=cycle_start; v = parent[v]){\ncycle.push_back(v);\n}\ncycle.push_back(cycle_start);\nreverse(cycle.begin(),cycle.end());\n}\nreturn cycle;\n}\n</code></pre> <p>Happy coding!</p>","tags":["cycle-finding","graph","ditected","undirected"]},{"location":"Algorithm/Graph/topo-sort/","title":"Topological Sort","text":"","tags":["topological-sort","graph","ditected","acyclic"]},{"location":"Algorithm/Graph/topo-sort/#introduction","title":"Introduction","text":"<p>Topological Sort is ordering the nodes of an acyclic graph such a way that, the full graph can be visited with minimul number of dfs calls all over again.</p> <ul> <li>Graph should be directed.</li> <li>Graph should not contain any cycle.</li> <li>Dfs is used.</li> <li>Time Complexity: O(m), where m is the number of edges.</li> </ul>","tags":["topological-sort","graph","ditected","acyclic"]},{"location":"Algorithm/Graph/topo-sort/#code","title":"Code","text":"<pre><code>#include&lt;iostream&gt;\n#include&lt;vector&gt;\nusing namespace std;\nvector&lt;vector&lt;int&gt;&gt;adj;\nvector&lt;bool&gt;visited;\nvector&lt;int&gt;sorted;\nvoid init(int len){\nadj.assign(len,vector&lt;int&gt;());\nvisited.assign(len,false);\nsorted.clear();\n}\nvoid sortDfs(int s){\nvisited[s]=true;\nfor(int v:adj[s]){\nif(!visited[v])sortDfs(v);\n}\nsorted.push_back(s);\n}\nvoid topological_sort(int l, int r){\nfor(int i=l;i&lt;=r;i++){\nif(!visited[i])sortDfs(i);\n}\nreverse(sorted.begin(),sorted.end());\n}\n</code></pre> <p>Happy coding!</p>","tags":["topological-sort","graph","ditected","acyclic"]},{"location":"Algorithm/Number-Theory/any-sol-linear-eqn/","title":"Diophantine Equation(Find any Solution)","text":"","tags":["diophantine-equation","any-solution","ex-gcd","ax + by = c"]},{"location":"Algorithm/Number-Theory/any-sol-linear-eqn/#introduction","title":"Introduction","text":"<p>ax + by = c is said to be Diophantine Equation of two variables, if the values of x,y are integers.</p> <ul> <li>It's possible to solve Diophantine Equations with the help of Extended Euclidean Algorithm.</li> <li>Time complexity: O(log(min(a,b))).</li> <li>Auxiliary memory complexity: O(1).</li> </ul>","tags":["diophantine-equation","any-solution","ex-gcd","ax + by = c"]},{"location":"Algorithm/Number-Theory/any-sol-linear-eqn/#intuition","title":"Intuition","text":"<p>The following theory will be helpful understanding Diophantine Equations.</p> <ul> <li>If, d = gcd(a,b) is not a divisor of c, there is \"No Solution\".</li> <li>(a=0, b=0 and c=0), any possible combination of integers can be a solution.</li> <li>(a=0, b!=0) or (a!=0, b=0), there is \"One Solution\".</li> <li>(a!=0 and b!=0), there are \"Infinately Many Solution\".</li> <li>If (x0,y0) is a solution of ax + by = c, all the solutions are:</li> </ul> \\[ \\left ( x,y \\right )=\\left (x_{0} + \\frac{b}{d}.k, y_{0} - \\frac{a}{d}.k \\right ) \\] <ul> <li>In Extended Euclidean Algorithm, the equation, ax + by = d is solved where, d = gcd(a,b). The solution can easily be transformed to:</li> </ul> \\[ a.x + b.y = d \\\\ \\Rightarrow a\\frac{x.c}{d} + b\\frac{y.c}{d} = c \\\\ \\Rightarrow a.X + b.Y = c \\] <ul> <li>Where \\(X=\\frac{x.c}{d}\\) and \\(Y=\\frac{y.c}{d}\\).</li> </ul>","tags":["diophantine-equation","any-solution","ex-gcd","ax + by = c"]},{"location":"Algorithm/Number-Theory/any-sol-linear-eqn/#code","title":"Code","text":"<pre><code>#include&lt;iostream&gt;\nusing namespace std;\nbool anySolution(ll a, ll b, ll c, ll &amp;x0, ll &amp;y0, ll &amp;d)\n{\nd = exGcd(abs(a), abs(b), x0, y0);\nif (c % d != 0)\nreturn false;\nx0 *= (c / d);\ny0 *= (c / d);\nif (a &lt; 0)\nx0 = -x0;\nif (b &lt; 0)\ny0 = -y0;\nreturn true;\n}\n</code></pre> <p>Happy coding!</p>","tags":["diophantine-equation","any-solution","ex-gcd","ax + by = c"]},{"location":"Algorithm/Number-Theory/ex-gcd/","title":"Extended Euclidean Algorithm","text":"","tags":["ex-gcd","ax + by = gcd(a,b)"]},{"location":"Algorithm/Number-Theory/ex-gcd/#introduction","title":"Introduction","text":"<p>Extended Euclidean Algorithm is the extended version of Euclidean algorithm which have the ability to find the GCD of two integers a,b. Additionally it can solve the following equation:</p> <pre><code>a*x + b*y = gcd(a, b)\n</code></pre> <ul> <li>Time complexity: O(log(min(a,b))).</li> <li>Auxiliary memory complexity: O(1).</li> </ul>","tags":["ex-gcd","ax + by = gcd(a,b)"]},{"location":"Algorithm/Number-Theory/ex-gcd/#intuition","title":"Intuitioniab(a / b)(a % b)xy","text":"<p>Extended Euclidean Algorithm is the application of Bezout's Identity. Which is, for a!=0 and b!=0, d=gcd(a,b), there exist integers x and y such as:</p> <pre><code>a*x + b*y = gcd(a, b)\n</code></pre> <ul> <li>It can find the value of x, y and gcd(a, b).</li> <li>If b=0, then x = 1, y = 0 and gcd = a.</li> <li>Else,</li> </ul> \\[   \\left\\{\\begin{matrix}   x_{i} = y_{i+1}\\\\   y_{i} = x_{i+1} - \\begin{Bmatrix}   y_{i+1}*\\left ( \\left \\lfloor \\frac{a_{i}}{b_{i}} \\right \\rfloor \\right )   \\end{Bmatrix}   \\end{matrix}\\right. \\] <ul> <li>Following table is showing the values of each steps to find the GCD of a=102, b=38 and the values of x,y in the equation, a*x + b*y = gcd(a,b)</li> </ul> 0 102 38 2 26 3 (X) -8 (Y) 1 38 26 1 12 -2 3 2 26 12 2 2 1 -2 3 12 2 6 0 0 1 4 2 (GCD) 0 - - 1 0","tags":["ex-gcd","ax + by = gcd(a,b)"]},{"location":"Algorithm/Number-Theory/ex-gcd/#code","title":"Code","text":"<pre><code>#include&lt;iostream&gt;\nusing namespace std;\nint exGcd( int a, int b, int&amp; x0, int&amp; y0 ) {\nif( b == 0 ) {\nx0 = 1;\ny0 = 0;\nreturn a;\n}\nint x1, y1;\nint d = exGcd( b, a % b, x1, y1 );\nx0 = y1;\ny0 = x1 - y1 * ( a / b );\nreturn d;\n}\n</code></pre> <p>Happy coding!</p>","tags":["ex-gcd","ax + by = gcd(a,b)"]},{"location":"Algorithm/Number-Theory/gcd/","title":"Euclidean Algorithm(GCD)","text":"","tags":["gcd","euclidean"]},{"location":"Algorithm/Number-Theory/gcd/#introduction","title":"Introduction","text":"<p>Greatest Common Divisors(GCD) of two integers a,b is the largest integer d which can divide both of the integers a,b.</p> <ul> <li>If b=0, gcd(a,b) = a.</li> <li>gcd(a,b) = gcd(b,a%b).</li> <li>Time complexity: O(log(min(a,b))).</li> <li>Auxiliary memory complexity: O(1).</li> </ul>","tags":["gcd","euclidean"]},{"location":"Algorithm/Number-Theory/gcd/#code","title":"Code","text":"<pre><code>#include&lt;iostream&gt;\nusing namespace std;\nint gcd( int a, int b ){\nif(b==0) return a;\nreturn gcd(b,a%b);\n}\n</code></pre> <p>Happy coding!</p>","tags":["gcd","euclidean"]},{"location":"Algorithm/Recursion%20%26%20DP/n-queen/","title":"N-Queen Problem","text":"","tags":["recursion","backtracking"]},{"location":"Algorithm/Recursion%20%26%20DP/n-queen/#introduction","title":"Introduction","text":"<p>The n-qeen problem is a puzzle to place n number of queens in an n x n chessboard. The only rule is that, no two queen to attack each other. The problem can be solved using backtracking.</p>","tags":["recursion","backtracking"]},{"location":"Algorithm/Recursion%20%26%20DP/n-queen/#code","title":"Code","text":"<pre><code>#include&lt;iostream&gt;\nusing namespace std;\nint taken[10]; // index-&gt;col, value-&gt;row\nint ct = 0; // Count of the valid board orientations\nbool valid(int col, int row){\nfor(int i=0;i&lt;col;i++){\nif(taken[i]==row||abs(i-col)==abs(taken[i]-row))return false;\n}\nreturn true;\n}\nvoid nQueen(int idx, int n){\nfor(int i=0;i&lt;n;i++){\nif(valid(idx,i)){\ntaken[idx]=i;\nif(idx==n-1){\nct++;\n// A valid orientation found &amp; saved in taken array. Do something...\n}\nelse nQueen(idx+1,n);\n}\n}\n}\nint main(){\nint n = 8;\nnQueen(0, n);\ncout&lt;&lt;\"Number of valid board orientations: \"&lt;&lt;ct&lt;&lt;endl;\nreturn 0;\n}\n</code></pre> <p>Happy coding!</p>","tags":["recursion","backtracking"]},{"location":"Array-Manipulation/count-subarray-having-xor-value-of-k/","title":"Count Subarray Having XOR Value of K","text":"","tags":["Array","XOR","Cumulative Sum"]},{"location":"Array-Manipulation/count-subarray-having-xor-value-of-k/#problem-statement","title":"Problem Statement","text":"<p>Given an array of integers A[] and a number K. The task is to count the number of subarrays the following conditions are true,</p> <ul> <li>A[] is an array of size n.</li> <li>[Ai...Aj] is a subarray of A[] where, (0 &lt;= i,j &lt; n).</li> <li>(Ai^Ai+1^...^Aj-1^Aj) = K, where ^ represents the XOR operation.</li> </ul>","tags":["Array","XOR","Cumulative Sum"]},{"location":"Array-Manipulation/count-subarray-having-xor-value-of-k/#input","title":"Input","text":"<pre><code>n = 3, A[] = {4, 2, 2, 6, 4}, K = 6\n</code></pre>","tags":["Array","XOR","Cumulative Sum"]},{"location":"Array-Manipulation/count-subarray-having-xor-value-of-k/#output","title":"Output","text":"<pre><code>Ans: 4\n</code></pre>","tags":["Array","XOR","Cumulative Sum"]},{"location":"Array-Manipulation/count-subarray-having-xor-value-of-k/#basics","title":"Basics","text":"<ul> <li>(a XOR 0) = a, where a is a variable.</li> <li>(a XOR a) = 0, XOR of same value is 0.</li> <li>(a XOR b XOR a) = b.</li> <li>if (a XOR b) = k, than (a XOR k) = b.</li> </ul>","tags":["Array","XOR","Cumulative Sum"]},{"location":"Array-Manipulation/count-subarray-having-xor-value-of-k/#solution","title":"Solution","text":"<p>We know that the total number of subarrays of an array of size n is, (n2 + n) / 2. So, if we want to calculate XOR values of each subarray individually, the complexity of the calculation will be atleast O(n2). In this case we can reduce the complexity to O(n) with the help of cumulative sum concept. Although we will use XOR instad of sum actually. Let's see how and why will it work. First of all we are creating an array Q[] of size n. Where Q[i] will contain the XOR value of, [A0...Ai], where (0 &lt;= i &lt; n). The follwing steps are followed to achive that,</p> <ul> <li>Q[0] = A[0].</li> <li>Q[i] = Q[i-1] ^ A[i], where (1 &lt;= i &lt; n).</li> </ul> <p>So, here we can see that,</p> <ul> <li>Q[p] = (A0^A1^...^Ap).</li> <li>Q[q] = (A0^A1^...^Aq).</li> <li>Q[p]^Q[q] = (Ap+1^...^Aq), where (p &lt; q) and the value is 0, when (p = q).</li> </ul> <p>With the help of the array Q[], we can easily calculate the XOR of any subarray of A[] with O(1) time complexity. Now, let [Ap+1...Aq] is a subarray where the XOR value is K. So, from the above discussion, we can say that,</p> <ul> <li>Q[p]^Q[q] = K.</li> <li>Q[p]^K = Q[q], [From the basics section].</li> <li>Q[p]^k = val, [Let, Q[q] = val].</li> </ul> <p>If we find the XOR of each value Q[p] in Q[] with K. We will get another value val. We have to calculate the total number of occueance of val in the array Q[] and add the number of occuerance to the ans. We can use counters to keep the occurence of each values in Q to avoid the complexity of counting each time. Also, it's very important to remember that, we are literally counting twice each value(just think how?). To avoid counting twice, we can count only the values in the indexes less than the current index while iterating from 0 to n-1.</p>","tags":["Array","XOR","Cumulative Sum"]},{"location":"Array-Manipulation/count-subarray-having-xor-value-of-k/#code","title":"Code","text":"<p><pre><code>#include&lt;iostream&gt;\nusing namespace std;\nint solve (int *A, int n, int K) {\nint Q[n+5];\nint mx = 0;\nfor (int i = 0; i&lt;n; i++) {\nif(i == 0) Q[i] = A[i];\nelse Q[i] = Q[i-1] ^ A[i];\nmx = (A[i] &gt; mx) ? A[i] : mx;\n}\nmx *= 2;\nint cnt[mx+5];\nfor (int i = 0; i &lt; mx + 5; i++) cnt[i] = 0;\ncnt[0] = 1;\nint ans = 0;\nfor(int i = 0; i &lt; n; i++) {\nint val = Q[i] ^ K;\nif (val &lt; mx + 5) {\nans += cnt[val];\n}\ncnt[Q[i]]++;\n}\nreturn ans;\n}\nint main() {\nint n = 5;\nint A[] = {4, 2, 2, 6, 4};\nint K = 6;\nint ans = solve (A, n, K);\ncout&lt;&lt;\"Ans: \"&lt;&lt;ans&lt;&lt;endl;\n}\n</code></pre> Happy Coding!</p>","tags":["Array","XOR","Cumulative Sum"]},{"location":"Code-Snippet/line-input/","title":"Line by Line Input C++","text":"","tags":["istringstream","C++"]},{"location":"Code-Snippet/line-input/#code","title":"Code","text":"<p><pre><code>string line;\ngetline(cin, line);\nistringstream is(line);\nint n;\nwhile(is &gt;&gt; n){\n//do something with n\n}\n</code></pre> Happy Coding!</p>","tags":["istringstream","C++"]},{"location":"Data-Structure/pbds/","title":"Policy-Based Data Structure(PBDS)","text":"","tags":["ordered_set","ordered_map"]},{"location":"Data-Structure/pbds/#introduction","title":"Introduction","text":"<p>PBDS provide some additional data structures not available in STL in C++.</p> <ul> <li>PBDS provide \"ordered_set\", \"ordered_map\" etc.</li> <li>\"ordered_set\" and \"ordered_map\" have the similar functionality of \"std::set\" and \"std::map\".</li> <li>Both of them have some additional functionalities like indexed access and fast iteration.</li> <li>Time Complexity of most functionalities: O(lon(n)).</li> </ul>","tags":["ordered_set","ordered_map"]},{"location":"Data-Structure/pbds/#ordered-set","title":"Ordered Set","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\n#include &lt;ext/pb_ds/assoc_container.hpp&gt;\n#include &lt;ext/pb_ds/tree_policy.hpp&gt;\nusing namespace __gnu_pbds;\ntypedef tree&lt;\nint,\nnull_type,\nless&lt;int&gt;,\nrb_tree_tag,\ntree_order_statistics_node_update&gt;\nordered_set;\n//Use less_equal&lt;int&gt; instad of less&lt;int&gt; for ordered-multiset\nint main(){\nordered_set oss;\n//insert value\noss.insert(b);\n//get the size\nll len=oss.size();\n//get index of value\nll pos=oss.order_of_key(val);\n//get value of the index\nll val=*oss.find_by_order(pos);\n//erase value by position\noss.erase(oss.find_by_order(pos));\n//find and delete value\nll pos=oss.order_of_key(a);\nll val=*oss.find_by_order(pos);\nif(a==val)oss.erase(oss.find_by_order(pos));\nreturn 0;\n}\n</code></pre>","tags":["ordered_set","ordered_map"]},{"location":"Data-Structure/pbds/#ordered-map","title":"Ordered Map","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;ext/pb_ds/assoc_container.hpp&gt;\n#include &lt;ext/pb_ds/tree_policy.hpp&gt;\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate &lt;typename K, typename V&gt;\nusing ordered_map = tree&lt;K, V, less&lt;K&gt;, rb_tree_tag, tree_order_statistics_node_update&gt;;\nint main() {\nordered_map&lt;int, int&gt; omap;\n// insert key-value pairs\nomap.insert({3, 30});\nomap.insert({1, 10});\nomap.insert({4, 40});\nomap.insert({2, 20});\n// get the size\ncout &lt;&lt; \"Size of map: \" &lt;&lt; omap.size() &lt;&lt; endl;\n// access value of a key\ncout &lt;&lt; \"Value of key 2: \" &lt;&lt; omap[2] &lt;&lt; endl;\n// erase a key-value pair by key\nomap.erase(3);\n// find and erase a key-value pair by key\nauto it = omap.find(2);\nif (it != omap.end()) omap.erase(it);\n// check if a key exists\ncout &lt;&lt; \"Key 4 exists: \" &lt;&lt; (omap.find(4) != omap.end()) &lt;&lt; endl;\n// get the index of a key\ncout &lt;&lt; \"Index of key 1: \" &lt;&lt; omap.order_of_key(1) &lt;&lt; endl;\n// get the key at a particular index\ncout &lt;&lt; \"Key at index 2: \" &lt;&lt; (*omap.find_by_order(2)).first &lt;&lt; endl;\n// get the value at a particular index\ncout &lt;&lt; \"Value at index 2: \" &lt;&lt; (*omap.find_by_order(2)).second &lt;&lt; endl;\n// clear the map\nomap.clear();\nreturn 0;\n}\n</code></pre> <p>Happy coding!</p>","tags":["ordered_set","ordered_map"]},{"location":"Data-Structure/sparse-table/","title":"Sparse Table","text":"","tags":["sparse-table","range-query"]},{"location":"Data-Structure/sparse-table/#introduction","title":"Introduction","text":"<p>Sparse table is a data structure to answer range queries. Sparse table has the following characterstics,</p> <ul> <li>Immutable DS, that means no update queries.</li> <li>Precalculation time complexity: O(nlogn).</li> <li>Auxiliary memory complexity: O(nlogn).</li> <li>Per query time complexity for idempotent functions: O(1), for associative functions: O(logn).</li> </ul>","tags":["sparse-table","range-query"]},{"location":"Data-Structure/sparse-table/#intuition","title":"Intuition","text":"<p>The following theory will be helpful understanding sparse table.</p> <ul> <li>Any non-nagetive number can be uniquely represented as a sum of decreasing power of two. E.g. 13 = (1101)2 = 8 + 4 + 1.</li> <li>Any interval can be uniquely represented as a union of intervels with lengths that are decreasing powers of two. E.g. \\([2, 14] = [2, 9] \\cup [10, 13] \\cup [14, 14]\\). Here the interval \\([2,14]\\) has the length of 13 and the intervals \\([2,9], [10,13], [14,14]\\) have the length of 8, 4 and 1 accordingly.</li> <li>Any interval can be represented as the union of log(length of the interval) number of intervals with lengths that are decreasing powers of two.</li> <li>The main idea of sparse table is to precompute all results for range queries with power of two length. Then for each query, the range is splitted into ranges with power of two lengths, get the precomputed results and combine to get the final result.</li> </ul>","tags":["sparse-table","range-query"]},{"location":"Data-Structure/sparse-table/#code","title":"Code","text":"<pre><code>#include&lt;iostream&gt;\nusing namespace std;\ntypedef long long ll;\nconst ll MXN=5e5;\nconst ll K=20;\nll n=1e5,k;\nll lg[MXN+5];\nll arr[MXN+5];\nll st[K+5][MXN+5];\nvoid setLog(){\nlg[0]=lg[1]=0;\nfor(ll i=2;i&lt;=MXN;i++)lg[i]=lg[i/2]+1;\n}\nll func(ll a, ll b){\n//Main operation here\n//ll val=(a&lt;b)?a:b; //Example of an idempotent function\nll val=a+b; //Example of an associative function\nreturn val;\n}\nvoid build(){\nsetLog();\nk=lg[n];\nk++;\nfor(ll i=0;i&lt;n;i++)st[0][i]=arr[i];\nfor(ll i=1;i&lt;=k;i++){\nfor(ll j=0;j+(1&lt;&lt;i)&lt;=n;j++){\nst[i][j]=func(st[i-1][j],st[i-1][j+(1&lt;&lt;(i-1))]);\n}\n}\n}\nll query_idemp_func(ll l, ll r){\nll i=lg[r-l+1];\nll ans=func(st[i][l],st[i][r-(1&lt;&lt;i)+1]);\nreturn ans;\n}\nll query_assoc_func(ll l, ll r){\nll ans=0; //base value, value depends on the function\nfor(ll i=k;i&gt;=0;i--){\nif((1&lt;&lt;i)&lt;=r-l+1){\nans=func(ans,st[i][l]);\nl+=(1&lt;&lt;i);\n}\n}\nreturn ans;\n}\n</code></pre>","tags":["sparse-table","range-query"]},{"location":"Data-Structure/sparse-table/#exmaple","title":"Exmaple","text":"<p>A list of numbers and queries or ranges are given. For each query, the result is the minumum value among the numbers between the ranges inclusive. All of them are zero indexed. As input, the following are given:</p> <ul> <li>First line, a number n, the length of the list of numbers.</li> <li>Second line, list of n numbers.</li> <li>Third line, a number q, the number of queries.</li> <li>The next q lines will two numbers l and r, representing the range [l,r] inclusive.</li> </ul>","tags":["sparse-table","range-query"]},{"location":"Data-Structure/sparse-table/#input","title":"Input","text":"<pre><code>3\n1 4 1\n2\n1 1\n1 2\n</code></pre>","tags":["sparse-table","range-query"]},{"location":"Data-Structure/sparse-table/#output","title":"Output","text":"<pre><code>4\n1\n</code></pre>","tags":["sparse-table","range-query"]},{"location":"Data-Structure/sparse-table/#code_1","title":"Code","text":"<p><pre><code>#include&lt;iostream&gt;\nusing namespace std;\ntypedef long long ll;\nconst ll MXN=5e5;\nconst ll K=20;\nll n=1e5,k;\nll lg[MXN+5];\nll arr[MXN+5];\nll st[K+5][MXN+5];\nvoid setLog(){\nlg[0]=lg[1]=0;\nfor(ll i=2;i&lt;=MXN;i++)lg[i]=lg[i/2]+1;\n}\nll func(ll a, ll b){\nll val=(a&lt;b)?a:b;\nreturn val;\n}\nvoid build(){\nsetLog();\nk=lg[n];\nk++;\nfor(ll i=0;i&lt;n;i++)st[0][i]=arr[i];\nfor(ll i=1;i&lt;=k;i++){\nfor(ll j=0;j+(1&lt;&lt;i)&lt;=n;j++){\nst[i][j]=func(st[i-1][j],st[i-1][j+(1&lt;&lt;(i-1))]);\n}\n}\n}\nll query(ll l, ll r){\nll i=lg[r-l+1];\nll ans=func(st[i][l],st[i][r-(1&lt;&lt;i)+1]);\nreturn ans;\n}\nint main(){\ncin&gt;&gt;n;\nfor(ll i=0;i&lt;n;i++)cin&gt;&gt;arr[i];\nbuild();\nll q,l,r;\ncin&gt;&gt;q;\nfor(ll i=0;i&lt;q;i++){\ncin&gt;&gt;l&gt;&gt;r;\nll ans=query(l,r);\ncout&lt;&lt;ans&lt;&lt;endl;\n}\nreturn 0;\n}\n</code></pre> Happy coding!</p>","tags":["sparse-table","range-query"]},{"location":"Magic-Solutions/K-th-Permutation/","title":"K-th Permutation of Sequence 1 to n","text":"","tags":["divide-and-conquer"]},{"location":"Magic-Solutions/K-th-Permutation/#problem","title":"Problem","text":"<p>There is an array of sequence [1,...,n] given. We have to find the permutation of the k-th permutation of the array.</p>","tags":["divide-and-conquer"]},{"location":"Magic-Solutions/K-th-Permutation/#solution","title":"Solution","text":"<p>We are going to divide this problem into smaller problems. We will try to solve, what is the first number of the k-th permutation of an array. Then the solution of the main problem will be found recursively.</p> <ul> <li>Array with n items have n! number of pernutations.</li> <li>Each value in the array will appare in the fist position for the permutation for (n-1)! times continuously and follow the assending order.</li> <li>The first (n-1)! permutations will contain smallest value at the first index, (n-1)! permutations after that will contain second smallest value at the first index and so on.</li> <li>Array={1,2,3}, n!=6, (n-1)!=2, k=3(0-indexed), permutations are:<ul> <li>{1,2,3}</li> <li>{1,3,2}</li> <li>{2,1,3}</li> <li>{2,3,1} (Target Permutation)</li> <li>{3,1,2}</li> <li>{3,2,1}</li> </ul> </li> <li>idx=k/(n-1)!=3/2=1. Value in the index-1 in the Array is: 2. So 2 will be places in the first index (index-0) in our target permutation {2,_,_}.</li> <li>k=k%(n-1)!=3%2=1, as we are done with one position, so we can reduce the value of k, so that it will remain in the range of the count of permutations on Array size smaller by one position.</li> <li>2 will be removed as we can't use it again, Array={1,3}.</li> <li>n=2, n!=2, (n-1)!=1, k=1, idx=1/1=1, Value in the index-1 in the current Array is: 3. So, 3 will be places in the second index in our target permutation {2,3,_}.</li> <li>k=1%1=0, Array={1}, n=1, So the remaining value will be placed in the remaining index of out permutation {2,3,1}.</li> </ul>","tags":["divide-and-conquer"]},{"location":"Magic-Solutions/K-th-Permutation/#code","title":"Code","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#include&lt;ext/pb_ds/assoc_container.hpp&gt;\n#include&lt;ext/pb_ds/tree_policy.hpp&gt;\nusing namespace __gnu_pbds;\n//For set functionality, indexed access and faster delete opperation\ntypedef tree&lt;\nint,\nnull_type,\nless&lt;int&gt;,\nrb_tree_tag,\ntree_order_statistics_node_update&gt;\nordered_set;\nvector&lt;int&gt; kthPermutation(int n, int k){\n//k--;//if k is 1-indexed\nvector&lt;int&gt;permutation;\nordered_set oss;\nfor(int i=1;i&lt;=n;i++)oss.insert(i);\n//Value of n!\nint fact = 1;\nfor(int i=2;i&lt;=n;i++){\nfact*=i;\n}\nfor(int i=n;i&gt;0;i--){\nfact/=i; // Value of (n-1)!\nint idx = (i==1)? 0 : (k/fact);\nk %= fact;\nint val=*oss.find_by_order(idx);\npermtation.push_back(val);\noss.erase(oss.find_by_order(idx));\n}\nreturn permutation; }\nint main(){\nint n=3;\nint k=3; //0-indexed\nvector&lt;int&gt;permutation = kthPermutation(n,k);\nfor(int i=0;i&lt;n;i++){\ncout&lt;&lt;permutation[i]&lt;&lt;\" \";\n}\ncout&lt;&lt;endl;\n}\n</code></pre> <p>Happy coding!</p>","tags":["divide-and-conquer"]},{"location":"Magic-Solutions/Longest-Palindromic-Subsequence/","title":"Longest Palindromic Subsequence","text":"","tags":["dynamic-programming","two-pointer"]},{"location":"Magic-Solutions/Longest-Palindromic-Subsequence/#problem","title":"Problem","text":"<p>A string of lowercase english letters will be given. The task is to find the length of the longest palindromic subsequence of the string.</p>","tags":["dynamic-programming","two-pointer"]},{"location":"Magic-Solutions/Longest-Palindromic-Subsequence/#solution","title":"Solution","text":"<p>The solution steps are simple as following:</p> <ul> <li>f(l,r) is a function which returns the length of the longest palindromic subsequence of the substring (s[l]...s[r]).</li> <li>Initiate l as the first index(0) and r as the last index(s.size()-1) of s.</li> <li>f(l,r) will return the following:<ul> <li>l=r, return 1.</li> <li>l&gt;r, return 0.</li> <li>s[l]=s[r], return 2+f(l+1,r-1).</li> <li>else, return max(f(l+1,r), f(l,r-1)).</li> </ul> </li> <li>f(l,r) will be saved in dp[l][r] to avoid calculation again.</li> </ul>","tags":["dynamic-programming","two-pointer"]},{"location":"Magic-Solutions/Longest-Palindromic-Subsequence/#code","title":"Code","text":"<pre><code>#include&lt;iostream&gt;\nusing namespace std;\nint dp[1010][1010];\nint ctDP(int l, int r, string&amp; s){\nif(l==r)return 1;\nif(l&gt;r)return 0;\nif(dp[l][r]!=-1)return dp[l][r];\nif(s[l]==s[r]) dp[l][r] = 2 + ctDP(l+1,r-1,s);\nelse dp[l][r] = max(ctDP(l+1,r,s),ctDP(l,r-1,s));\nreturn dp[l][r];\n}\nint main(){\nfor(int i=0;i&lt;1010;i++){\nfor(int j=0;j&lt;1010;j++)dp[i][j]=-1;\n}\nstring s = \"bbbab\";\nint l=0, r=s.size()-1;\nint ans = ctDP(l,r,s);\ncout&lt;&lt;ans&lt;&lt;endl;\nreturn 0;\n}\n</code></pre> <p>Happy coding!</p>","tags":["dynamic-programming","two-pointer"]},{"location":"Magic-Solutions/maximum-sum-from-n-stacks-k-numbers/","title":"Maximum Sum of K Positive Numbers from N Stacks","text":"","tags":["dynamic-programming","dimension-reduction"]},{"location":"Magic-Solutions/maximum-sum-from-n-stacks-k-numbers/#problem","title":"Problem","text":"<p>There are n number of stacks of positive numbers are given. The task is to take k numbers from the stacks, so that the summation of the taken numbers is maximized.</p> <ul> <li>From a stack, only the top item can be taken. After removing the top item, the next item get to the top.</li> </ul>","tags":["dynamic-programming","dimension-reduction"]},{"location":"Magic-Solutions/maximum-sum-from-n-stacks-k-numbers/#solution","title":"Solution","text":"<ul> <li>Traverse the stacks from left or right.</li> <li>Take as much numbers as we want or allowed (posibly zero) from that stack and move forward, don't come back.</li> <li>Keep the maximum value at each state.</li> <li>Memorize to avoid recalculation.</li> </ul>","tags":["dynamic-programming","dimension-reduction"]},{"location":"Magic-Solutions/maximum-sum-from-n-stacks-k-numbers/#code","title":"Code","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint dp[1010][2010]; //memorization\nint n; // will keep the number of stacks\nvector&lt;vector&lt;int&gt;&gt;stacks; // stacks\nvoid init(){\nfor(int i=0;i&lt;10101;i++){\nfor(int j=0;j&lt;2010;j++)dp[i][j]=-1;\n}\n}\nint ctDP(int idx, int k){\nif(idx&gt;=n||k&lt;=0)return 0;\nif(dp[idx][k]!=-1)return dp[idx][k];\nint m=stacks[idx].size();\nint sum=0;\nfor(int i=0;i&lt;=min(m,k);i++){\nif(i!=0)sum+=stacks[idx][i-1];\ndp[idx][k]=max(dp[idx][k],sum+ctDP(idx+1,k-i));\n}\nreturn dp[idx][k];\n}\nint main(){\n//load_input(); //load stacks\nn = stacks.size();\ninit();\nint ans=ctDP(0,k);\ncout&lt;&lt;ans&lt;&lt;endl;\nreturn 0;\n}\n</code></pre> <p>Happy coding!</p>","tags":["dynamic-programming","dimension-reduction"]},{"location":"Problem-Solving/my-solutions/","title":"Problems I Solved!","text":"<p>You will find the solutions to problems I solved on online judges in my github account. Follow the github link in the footer section below...</p> <p>Happy coding!</p>","tags":["solutions","online-judge"]},{"location":"SQL/basic/","title":"Basic SQL Queries","text":"<p>SQL stands for Structured Query Language which is a RDB(Relational Database). SQL lets you access and manipulate databases. Some basic SQL queries are given below:</p>","tags":["SQL"]},{"location":"SQL/basic/#select","title":"SELECT","text":"<p>The SELECT statement is used to select data from a database. The data returned is stored in a result table, called the result-set.</p> <p>Syntex <pre><code>SELECT column1, column2, ...\nFROM table_name;\n</code></pre> Example 1 <pre><code>SELECT CustomerName, City FROM Customers;\n</code></pre> Example 2 <pre><code>SELECT * FROM Customers;\n</code></pre></p>","tags":["SQL"]},{"location":"SQL/basic/#select-distinct","title":"SELECT DISTINCT","text":"<p>The SELECT DISTINCT statement is used to return only distinct (different) values. Inside a table, a column often contains many duplicate values; and sometimes you only want to list the different (distinct) values.</p> <p>Syntex <pre><code>SELECT DISTINCT column1, column2, ...\nFROM table_name;\n</code></pre> Example 1 <pre><code>SELECT DISTINCT Country FROM Customers;\n</code></pre></p> <p>The following SQL statement lists the number of different (distinct) customer countries.</p> <p>Example 2 (Doesn't work on MS Access) <pre><code>SELECT COUNT(DISTINCT Country) FROM Customers;\n</code></pre></p> <p>Example 3 (For MS Access) <pre><code>SELECT Count(*) AS DistinctCountries\nFROM (SELECT DISTINCT Country FROM Customers);\n</code></pre></p>","tags":["SQL"]},{"location":"SQL/basic/#where","title":"WHERE","text":"<p>The WHERE clause is used to filter records. It is used to extract only those records that fulfill a specified condition.</p> <p>Syntex <pre><code>SELECT column1, column2, ...\nFROM table_name\nWHERE condition;\n</code></pre> Example 1 <pre><code>SELECT * FROM Customers\nWHERE Country='Mexico';\n</code></pre> Example 2 <pre><code>SELECT * FROM Customers\nWHERE CustomerID=1;\n</code></pre> Operators in The WHERE Clause</p> Operator Description = Equal &gt; Greater than &lt; Less than &gt;= Greater than or equal &lt;= Less than or equal &lt;&gt; Not equal. Note: In some versions of SQL this operator may be written as != BETWEEN Between a certain range LIKE Search for a pattern IN To specify multiple possible values for a column","tags":["SQL"]},{"location":"SQL/basic/#and-or-and-not","title":"AND, OR and NOT","text":"<p>The WHERE clause can be combined with AND, OR, and NOT operators. The AND and OR operators are used to filter records based on more than one condition:</p> <ul> <li>The AND operator displays a record if all the conditions separated by AND are TRUE.</li> <li>The OR operator displays a record if any of the conditions separated by OR is TRUE.</li> </ul> <p>The NOT operator displays a record if the condition(s) is NOT TRUE.</p> <p>AND Syntex <pre><code>SELECT column1, column2, ...\nFROM table_name\nWHERE condition1 AND condition2 AND condition3 ...;\n</code></pre> OR Syntex <pre><code>SELECT column1, column2, ...\nFROM table_name\nWHERE condition1 OR condition2 OR condition3 ...;\n</code></pre> AND Syntex <pre><code>SELECT column1, column2, ...\nFROM table_name\nWHERE NOT condition;\n</code></pre> Example 1 <pre><code>SELECT * FROM Customers\nWHERE Country='Germany' AND City='Berlin';\n</code></pre> Example 2 <pre><code>SELECT * FROM Customers\nWHERE City='Berlin' OR City='M\u00fcnchen';\n</code></pre> Example 3 <pre><code>SELECT * FROM Customers\nWHERE NOT Country='Germany';\n</code></pre> Example 4 <pre><code>SELECT * FROM Customers\nWHERE Country='Germany' AND (City='Berlin' OR City='M\u00fcnchen');\n</code></pre> Example 5 <pre><code>SELECT * FROM Customers\nWHERE NOT Country='Germany' AND NOT Country='USA';\n</code></pre></p>","tags":["SQL"]},{"location":"SQL/basic/#order-by","title":"ORDER BY","text":"<p>The ORDER BY keyword is used to sort the result-set in ascending or descending order. The ORDER BY keyword sorts the records in ascending order by default. To sort the records in descending order, use the DESC keyword.</p> <p>Syntax <pre><code>SELECT column1, column2, ...\nFROM table_name\nORDER BY column1, column2, ... ASC|DESC;\n</code></pre> Example 1 <pre><code>SELECT * FROM Customers\nORDER BY Country;\n</code></pre> Example 2 <pre><code>SELECT * FROM Customers\nORDER BY Country DESC;\n</code></pre> Example 3 <pre><code>SELECT * FROM Customers\nORDER BY Country, CustomerName;\n</code></pre> Example 4 <pre><code>SELECT * FROM Customers\nORDER BY Country ASC, CustomerName DESC;\n</code></pre></p>","tags":["SQL"]},{"location":"SQL/basic/#insert-into","title":"INSERT INTO","text":"<p>The INSERT INTO statement is used to insert new records in a table. It is possible to write the INSERT INTO statement in two ways:</p> <ul> <li>Specify both the column names and the values to be inserted</li> <li>Adding values for all the columns of the table</li> </ul> <p>Syntex for specified columns and values <pre><code>INSERT INTO table_name (column1, column2, column3, ...)\nVALUES (value1, value2, value3, ...);\n</code></pre> Syntex for all columns <pre><code>INSERT INTO table_name\nVALUES (value1, value2, value3, ...);\n</code></pre> Example 1 <pre><code>INSERT INTO Customers\nVALUES (null, 'Cardinal', 'Tom B. Erichsen', 'Skagen 21', 'Stavanger', '4006', 'Norway');\n</code></pre> Example 2 <pre><code>INSERT INTO Customers (CustomerName, City, Country)\nVALUES ('Cardinal', 'Stavanger', 'Norway');\n</code></pre></p>","tags":["SQL"]},{"location":"SQL/basic/#null","title":"NULL","text":"<p>It is not possible to test for NULL values with comparison operators, such as =, &lt;, or &lt;&gt;. We will have to use the IS NULL and IS NOT NULL operators instead.</p> <p>IS NULL Syntex <pre><code>SELECT column_names\nFROM table_name\nWHERE column_name IS NULL;\n</code></pre> IS NOT NULL Syntex <pre><code>SELECT column_names\nFROM table_name\nWHERE column_name IS NOT NULL;\n</code></pre> Example 1 <pre><code>SELECT CustomerName, ContactName, Address\nFROM Customers\nWHERE Address IS NULL;\n</code></pre> Example 2 <pre><code>SELECT CustomerName, ContactName, Address\nFROM Customers\nWHERE Address IS NOT NULL;\n</code></pre></p>","tags":["SQL"]},{"location":"SQL/basic/#update","title":"UPDATE","text":"<p>The UPDATE statement is used to modify the existing records in a table.</p> <p>Syntex <pre><code>UPDATE table_name\nSET column1 = value1, column2 = value2, ...\nWHERE condition;\n</code></pre> Example 1 <pre><code>UPDATE Customers\nSET ContactName = 'Alfred Schmidt', City= 'Frankfurt'\nWHERE CustomerID = 1;\n</code></pre> Example 2 <pre><code>UPDATE Customers\nSET ContactName='Juan'\nWHERE Country='Mexico';\n</code></pre></p>","tags":["SQL"]},{"location":"SQL/basic/#delete","title":"DELETE","text":"<p>The DELETE statement is used to delete existing records in a table.</p> <p>Syntex <pre><code>DELETE FROM table_name WHERE condition;\n</code></pre> Syntex for deleting all content in the table while keeping the structure <pre><code>DELETE FROM table_name;\n</code></pre> Example 1 <pre><code>DELETE FROM Customers WHERE CustomerName='Alfreds Futterkiste';\n</code></pre> Example 2 <pre><code>DELETE FROM Customers;\n</code></pre></p> <p>Happy Coding!</p>","tags":["SQL"]},{"location":"Tips-And-Tricks/c-sharp-setup-for-linux-users/","title":"C# Environment Setup for Linux(deb) Users","text":"","tags":["C#","C-Sharp","Linux","Terminal","Mono"]},{"location":"Tips-And-Tricks/c-sharp-setup-for-linux-users/#install-compiler","title":"Install Compiler","text":"<p>Open the terminal and execute the following command, <pre><code>sudo apt install mono-complete\n</code></pre></p>","tags":["C#","C-Sharp","Linux","Terminal","Mono"]},{"location":"Tips-And-Tricks/c-sharp-setup-for-linux-users/#c-example","title":"C# Example","text":"<p>Create a file named test.cs with the following content and save the file. <pre><code>using System;\npublic class Hello {\nstatic public void Main()\n{\nConsole.WriteLine(\"Hello World!\");\nConsole.ReadKey();\n}\n}\n</code></pre></p>","tags":["C#","C-Sharp","Linux","Terminal","Mono"]},{"location":"Tips-And-Tricks/c-sharp-setup-for-linux-users/#build-and-run","title":"Build and Run","text":"<p>Open the terminal in the same folder/directory that contains our test.cs example file. Then execute the following command to set the apropreate permission. <pre><code>sudo chmod +x test.cs\n</code></pre> To build the test.exe executable file, <pre><code>mcs -out:test.exe test.cs\n</code></pre> To run the test.exe executable file, <pre><code>mono test.exe\n</code></pre></p>","tags":["C#","C-Sharp","Linux","Terminal","Mono"]},{"location":"Tips-And-Tricks/c-sharp-setup-for-linux-users/#output","title":"Output","text":"<pre><code>Hello World!\n</code></pre> <p>Happy Coding!</p>","tags":["C#","C-Sharp","Linux","Terminal","Mono"]},{"location":"Tips-And-Tricks/my-cp-template/","title":"My CP Template","text":"","tags":["C++","CP"]},{"location":"Tips-And-Tricks/my-cp-template/#template","title":"Template","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#include &lt;ext/pb_ds/assoc_container.hpp&gt;\nusing namespace __gnu_pbds;\ntypedef tree&lt;int,null_type,less&lt;int&gt;,rb_tree_tag,\ntree_order_statistics_node_update&gt; indexed_set; //less_equal for multi-set\n#define endl '\\n'\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\nll t=1;\n//cin&gt;&gt;t;\nfor(ll T=1;T&lt;=t;T++){\n//code here\n}\nreturn 0;\n}\n</code></pre>","tags":["C++","CP"]}]}